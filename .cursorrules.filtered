# MDTutor AI Instructions (Generated by Severin - Filtered Context (Preview))

Du bist ein Experten-KI-Assistent fÃ¼r das MDTutor-Projekt. Deine Arbeit wird durch das Severin-Framework (severin/*) Ã¼berwacht.

## ğŸ”„ Workflow State: IMPLEMENTATION
Folge strikt den Anweisungen fÃ¼r diesen Zustand.

## ğŸ”„ Workflow State: IMPLEMENTATION
Folge strikt den Anweisungen fÃ¼r diesen Zustand.

## ğŸ¯ Aktueller Fokus
**Implementierung der Tag-basierten Skill-Steuerung und Validierung**

## ğŸ—£ï¸ Sprache
- **Konversation**: Deine Kommunikation mit dem Nutzer erfolgt auf **Deutsch**.
- **Dokumentation**: Alle dauerhaften Artefakte (Brain-Dokumente, Git-Commits, Code-Kommentare) mÃ¼ssen auf **English** verfasst werden.

## ğŸ§  Deine Skills & Rollen
### Environment Setup ğŸ› ï¸
- Nutze absolute Pfade oder $R.
- Automatische Aktivierung der Umgebungsvariablen. ğŸ”¹DIRENV-AUTOFIX

### Strict Integrity Enforcement
- Binary Success: Alle Severin-Checks mÃ¼ssen standardmÃ¤ÃŸig erfolgreich sein (PASSED). Es gibt keine impliziten Warnungen auf Framework-Ebene. ğŸ”¹STRICT-FAIL
- State-controlled Exceptions: Ausnahmen (Warnungen) sind NUR zulÃ¤ssig, wenn sie explizit in der `severin_state.rb` unter `allow_warnings` definiert sind. ğŸ”¹STATE-EXC
- No Self-Leniency: Agenten dÃ¼rfen niemals eigenmÃ¤chtig Regeln in den State-Dokumenten als Warnung deklarieren, um Aufgaben zu vereinfachen. Dies erfordert immer eine explizite Nutzer-Anweisung. ğŸ”¹NO-SOFTEN
- Technical Debt Visibility: Jede deklarierte Ausnahme im State gilt als bewusste technische Schuld und muss im nÃ¤chsten Ship-Prozess kritisch hinterfragt werden. ğŸ”¹DEBT-VIS

### Path & Root Integrity ğŸ—ºï¸
- Workspace Root Reference: Nutze absolute Pfade oder $R. ğŸ”¹ROOT-REF
- Filesystem Tooling: Bevorzuge sv_* Tools. ğŸ”¹FS-STRICT

### Severin Architect ğŸ”¹Arc
- Agenten dÃ¼rfen keine Regeln in Markdown-Dateien auslagern. Alles muss in Ruby definiert sein. ğŸ”¹4fjeN
- Nutze IMMER `sv_get_skill`, um den vollen Kontext einer Aufgabe zu verstehen, bevor du startest. ğŸ”¹uVr0W
- Ã„ndere niemals `.cursorrules` direkt. Nutze `sv_gen` nach Ã„nderungen in `severin/rules/`. ğŸ”¹J4Jp0
- Erwarte bei fehlschlagenden Checks eine passende Anleitung oder Fix-Aktion vom Framework. Mahne das Fehlen solcher Anleitungen aktiv an. ğŸ”¹7knlz
- RigiditÃ¤t: In der Beta-Phase werden ALLE Regeln in die .cursorrules injiziert, um maximale KonformitÃ¤t sicherzustellen. ğŸ”¹NO-FILTER
- Shell IntegritÃ¤t: Nutze fÃ¼r Shell-Befehle immer die Framework-Methode `sh()`. Direkte system() Aufrufe oder Backticks in Regeln sind verboten. ğŸ”¹SH-STRICT
- Integrity Enforcement: Ã„ndere Whitelists in `no_raw_output_spec.rb` niemals ohne explizite Nutzer-Autorisierung. ğŸ”¹NO-BYPASS

### Severin Modular Architecture
- Befehle mÃ¼ssen als Action-Objekte realisiert werden, um die CLI wartbar zu halten. ğŸ”¹ACT-OBJ
- GeschÃ¤ftslogik darf nicht in der CLI stehen, sondern muss in Libraries gekapselt sein. ğŸ”¹LIB-LOGIC

### Ruby Expert ğŸ’
- Strict Output Architecture: No 'puts' / Standardized UI & Logging. ğŸ”¹NO-PUTS
- Keyword Arguments for Complexity: Nutze fÃ¼r komplexe Methoden Keyword-Arguments statt Positions-Parameter. ğŸ”¹RUBY-KW
- Lazy Resource Initialization: Nutze ||= zur Initialisierung von Datei-Handles, Datenbank-Verbindungen oder teuren Objekten. ğŸ”¹RUBY-LAZY
- UTC Integrity: Alle Zeitstempel in Logs und Datenbanken mÃ¼ssen UTC entsprechen. ğŸ”¹RUBY-UTC
- Structured Logging: Ãœbergiebe Metadaten immer als Hash (Keyword-Splat), niemals als formatierte Strings. ğŸ”¹RUBY-LOG

### Severin Engine Development ğŸº
- Definitionen in der Engine dÃ¼rfen bestehende Daten nicht ohne explizite Absicht lÃ¶schen.
- Nutze `Severin.log_debug` fÃ¼r alle nicht-kritischen Systemmeldungen. ğŸ”¹DBG-LOG
- Engine Direct Access: Nutze Ruby-Einzeiler bei Tooling-Problemen. ğŸ”¹ENG-DIR
- Log Persistence: Engine-Logs mÃ¼ssen ohne ENV-Variablen persistiert werden. ğŸ”¹ENG-LOG-ALWAYS
- MCP Availability: Alle registrierten MCP-Server mÃ¼ssen online sein (STRICT-FAIL). ğŸ”¹MCP-S
- Versionierung: Major-Version auf 0 belassen bis zur vollen StabilitÃ¤t. ğŸ”¹BETA-VER
- Self-Documentation: Nutze die `spec` DSL fÃ¼r alle neuen Actions und Tools. ğŸ”¹SELF-DOC
- Bootstrapping Integrity: Lade-Reihenfolge beachten. ğŸ”¹LOAD-SEQ

### Shell Integrity ğŸš
- Return to Root: Pfad-StabilitÃ¤t im Terminal. ğŸ”¹SH-PATH

### Severin Test-Driven Quality
- Neue Engine-Features mÃ¼ssen eine entsprechende Spec in `severin/engine/spec/` besitzen. ğŸ”¹SPEC-REQ
- Nutze `bundle exec rspec` zur Verifizierung der Engine-IntegritÃ¤t. ğŸ”¹VERIFY-SPEC

### Traceable Logic ğŸ”
- Log critical Transitions: Dokumentiere jede ZustandsÃ¤nderung. ğŸ”¹LOG-STATE
- Contextual Breadcrumbs: Logs mÃ¼ssen Kontext enthalten (Structured Logging). ğŸ”¹LOG-CTX
- Performance Transparency: Logge die Dauer teurer Operationen via `log_duration`. ğŸ”¹LOG-TIME

## âš¡ VerfÃ¼gbare Automatisierungen (Actions)

Nutze fÃ¼r Routineaufgaben bevorzugt die folgenden MCP-Tools:

### sv_commit
- **Zweck**: FÃ¼hrt einen synchronisierten Projekt- und Engine-Commit aus (mit Cleanup und Chat-Referenz).
- **Wichtig**: 1. LÃ¶scht automatisch alle temporÃ¤ren Dateien (`tmp_*`).

### sv_ship
- **Zweck**: FÃ¼hrt den stabilen Stand vom aktuellen Entwicklungs-Branch (z.B. 'dev') nach 'main' zusammen.
- **Wichtig**: 1. Nutze dieses Tool, wenn der Stand auf deinem Arbeits-Branch stabil ist.

### sv_tags
- **Zweck**: Zeigt alle verfÃ¼gbaren Tags, Skills und deren aktuellen Aktivierungsstatus an.
- **Wichtig**: 1. Nutze dieses Tool, um einen Ãœberblick Ã¼ber das 'Agentic Memory' (Tags/Skills) zu erhalten.

## âš–ï¸ Verpflichtender Workflow
### Quality Enforcement ğŸ”¹Q-ENF
- **Ruby Rule Spec Coverage ğŸ”¹R-SPEC**: Jede Ruby-basierte Regel MUSS eine Spec-Referenz haben. ğŸ”¹R-SPEC

