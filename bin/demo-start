#!/bin/bash
set -e

# MDTutor Demo Start Script
# -------------------------

ENV_FILE="docker.env"
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}=== MDTutor Demo Launcher ===${NC}\n"

# 0. Check for Updates
if [ -d .git ]; then
    echo -e "Prüfe auf Updates von Upstream..."
    # Suppress output to keep it clean
    git fetch origin >/dev/null 2>&1 || echo -e "${YELLOW}Hinweis: Konnte nicht von Upstream abrufen (kein Internet?)${NC}"
    
    LOCAL_COMMIT=$(git rev-parse HEAD)
    # Check if there's an upstream branch tracked
    UPSTREAM_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")
    
    if [ -z "$UPSTREAM_BRANCH" ]; then
         echo -e "${YELLOW}Hinweis: Kein Upstream-Branch zum Tracken gefunden.${NC}"
    else
        REMOTE_COMMIT=$(git rev-parse "$UPSTREAM_BRANCH")
        if [ "$LOCAL_COMMIT" != "$REMOTE_COMMIT" ]; then
            echo -e "${YELLOW}Updates gefunden. Ziehe Änderungen...${NC}"
            if git pull; then
                echo -e "${GREEN}Projekt aktualisiert. Starte Skript neu...${NC}"
                exec "$0" "$@"
            else
                echo -e "${RED}Fehler beim Aktualisieren. Bitte manuell prüfen.${NC}"
            fi
        else
            echo -e "${GREEN}Projekt ist auf dem neuesten Stand.${NC}"
        fi
    fi
fi

# 1. Detect Environment
IS_WSL=0
if grep -qi microsoft /proc/version 2>/dev/null; then
    IS_WSL=1
fi

DEFAULT_DOMAIN="mdtutor.test"
if [ $IS_WSL -eq 1 ]; then
    DEFAULT_DOMAIN="mdtutor.localhost"
fi

# 2. Check if docker.env exists
if [ ! -f "$ENV_FILE" ]; then
    echo -e "${YELLOW}Hinweis: $ENV_FILE wurde nicht gefunden.${NC}"
    if [ $IS_WSL -eq 1 ]; then
        echo -e "WSL2 erkannt. Nutze ${YELLOW}$DEFAULT_DOMAIN${NC} als Standard-Domain."
    fi
    read -p "Soll ich $ENV_FILE aus der Vorlage erstellen? (y/N) " create_env
    if [[ $create_env =~ ^[Yy]$ ]]; then
        cp docker.env.example docker.env
        
        # Set default domain based on environment
        sed -i "s/DOMAIN=.*/DOMAIN=$DEFAULT_DOMAIN/" docker.env
        
        # Try to fill in master keys automatically
        BE_KEY=$(cat packages/backend-ruby/config/master.key 2>/dev/null || echo "")
        SSO_KEY=$(cat packages/sso-server/config/master.key 2>/dev/null || echo "")
        
        if [ -n "$BE_KEY" ]; then
            sed -i "s/.*ACHIEVEMENTS_MASTER_KEY=.*/ACHIEVEMENTS_MASTER_KEY=$BE_KEY/" docker.env
        fi
        if [ -n "$SSO_KEY" ]; then
            sed -i "s/.*SSO_MASTER_KEY=.*/SSO_MASTER_KEY=$SSO_KEY/" docker.env
        fi
        # Generate random JWT secret
        JWT_SECRET=$(openssl rand -hex 32 2>/dev/null || echo "demo_secret_$(date +%s)")
        sed -i "s/SSO_JWT_SECRET=.*/SSO_JWT_SECRET=$JWT_SECRET/" docker.env
        
        echo -e "${GREEN}✓ $ENV_FILE wurde erstellt und mit Keys aus den packages befüllt.${NC}"
    else
        echo -e "${RED}Fehler: $ENV_FILE wird benötigt.${NC}"
        exit 1
    fi
fi

# 3. Load environment and check for missing values
source "$ENV_FILE"

MISSING=0
if [ -z "$ACHIEVEMENTS_MASTER_KEY" ] || [ "$ACHIEVEMENTS_MASTER_KEY" == "KEY_FEHLT" ]; then
    echo -e "${RED}⚠ ACHIEVEMENTS_MASTER_KEY ist nicht gesetzt!${NC}"
    MISSING=1
fi
if [ -z "$SSO_MASTER_KEY" ] || [ "$SSO_MASTER_KEY" == "KEY_FEHLT" ]; then
    echo -e "${RED}⚠ SSO_MASTER_KEY ist nicht gesetzt!${NC}"
    MISSING=1
fi

if [ $MISSING -eq 1 ]; then
    echo -e "\nBitte ergänze die fehlenden Keys in ${YELLOW}$ENV_FILE${NC}."
    exit 1
fi

# 4. Instruction for Local DNS
echo -e "${GREEN}Prüfung abgeschlossen.${NC}"

PORT_SUFFIX=""
if [ -n "$TRAEFIK_PORT" ] && [ "$TRAEFIK_PORT" != "80" ]; then
    PORT_SUFFIX=":$TRAEFIK_PORT"
fi

MAIN_DOMAIN="${DOMAIN:-$DEFAULT_DOMAIN}"
SSO_DOMAIN="sso.${MAIN_DOMAIN}"

echo -e "Die Demo wird unter folgenden Domains erreichbar sein:"
echo -e " - http://${MAIN_DOMAIN}${PORT_SUFFIX}"
echo -e " - http://${SSO_DOMAIN}${PORT_SUFFIX}"
echo ""

# Active DNS Check
echo -e "Prüfe DNS-Auflösung..."
DNS_OK=1

check_dns() {
    local domain=$1
    if ! ping -c 1 -W 1 "$domain" >/dev/null 2>&1; then
        if ! host "$domain" >/dev/null 2>&1 && ! getent hosts "$domain" >/dev/null 2>&1; then
            echo -e "${RED}✖ $domain konnte nicht aufgelöst werden!${NC}"
            return 1
        fi
    fi
    echo -e "${GREEN}✓ $domain ist erreichbar${NC}"
    return 0
}

check_dns "$MAIN_DOMAIN" || DNS_OK=0
check_dns "$SSO_DOMAIN" || DNS_OK=0

if [ $DNS_OK -eq 0 ]; then
    echo -e "\n${YELLOW}Hinweis:${NC} Die Domains scheinen nicht auf diesen Rechner zu zeigen."
    echo -e "Vorgeschlagener Eintrag: ${GREEN}127.0.0.1  $MAIN_DOMAIN $SSO_DOMAIN${NC}"
    echo ""
    read -p "Soll ich versuchen, diesen Eintrag automatisch zu /etc/hosts hinzuzufügen? (y/N) " fix_dns
    if [[ $fix_dns =~ ^[Yy]$ ]]; then
        echo "Prüfe auf sudo-Berechtigungen..."
        if sudo bash -c "echo '127.0.0.1  $MAIN_DOMAIN $SSO_DOMAIN' >> /etc/hosts"; then
            echo -e "${GREEN}✓ /etc/hosts wurde aktualisiert.${NC}"
            if [ $IS_WSL -eq 1 ]; then
                echo -e "${YELLOW}Hinweis für WSL2:${NC} Falls dein Browser auf Windows die Domain noch nicht findet,"
                echo -e "musst du sie auch in ${YELLOW}C:\\Windows\\System32\\drivers\\etc\\hosts${NC} eintragen."
            fi
            DNS_OK=1
        else
            echo -e "${RED}✖ Fehlgeschlagen. Bitte manuell eintragen.${NC}"
        fi
    fi

    if [ $DNS_OK -eq 0 ]; then
        read -p "Trotzdem fortfahren? (y/N) " confirm
        if [[ ! $confirm =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi
fi

# 5. Check for Docker
if ! docker info >/dev/null 2>&1; then
    echo -e "${RED}Fehler: Docker scheint nicht zu laufen oder du hast keine Berechtigung.${NC}"
    exit 1
fi

# Detect Docker API Version for Traefik compatibility
DOCKER_VERSION=$(docker version --format '{{.Client.APIVersion}}' 2>/dev/null || echo "1.41")
export DOCKER_API_VERSION=$DOCKER_VERSION

# Active Content Structure Check
echo -e "Prüfe Content-Struktur..."
if ! node --test test/structure-compliance.test.js >/dev/null 2>&1; then
    echo -e "${YELLOW}Achtung: Content-Struktur ist nicht korrekt.${NC}"
    read -p "Soll ich den Content jetzt initialisieren? (y/N) " init_content
    if [[ $init_content =~ ^[Yy]$ ]]; then
        ./bin/content-init
    fi
fi

# 6. Run Docker Compose
echo -e "${GREEN}Starte Docker-Container...${NC}"
COMMIT_HASH=$(git rev-parse HEAD 2>/dev/null || echo "unknown")

COMMIT_HASH=$COMMIT_HASH docker-compose --env-file "$ENV_FILE" up -d --build --remove-orphans

echo -e "\n${GREEN}Demo läuft!${NC}"
echo -e "Nutze ${YELLOW}docker-compose logs -f${NC} für Live-Logs."

# 7. Optional Clean-up
echo ""
read -p "Soll ich ungenutzte Docker-Images bereinigen (prune)? (y/N) " prune_images
if [[ $prune_images =~ ^[Yy]$ ]]; then
    docker image prune -f
    echo -e "${GREEN}✓ Bereinigung abgeschlossen.${NC}"
fi

